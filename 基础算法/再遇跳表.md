这一篇将更加细致的介绍跳表的演进过程。

## 有序数组

我们知道，数组是支持随机访问的，即通过下标可以快速地定位到元素，时间复杂度为O(1)。那么，这个随机访问的特性除了根据下标查找元素，还具有哪些用处呢？

试想，如果一个数组是有序的，要查找某个指定的元素，如何才能最快速地查找出来呢？

+ 从头开始遍历整个数组，遇到要查找的元素就返回。这种查找方式的时间复杂度为O(n)。

+ 数据本身有序，所以可以进行二分查找，先从中间元素开始查找，如果指定元素小于中间元素，再在左半边查找；如果指定元素大于中间元素大，就在右半边查找，循环往复，直到找到指定元素。这种方式最坏情况的时间复杂度为O(logn)，效率提升了可不是一星半点。

  > 比如，在1 、3、4、6、7、8、9、10这个有序数组arr中，查找8这个元素。
  >
  > 开始时左指针为0，右指针为7，先定位到中间位置（0+7）/2=3，发现8大于arr[3]=6；第二次查找左指针为3+1=4，右指针依然为7，此时中间位置为（4+7）/2=5，发现8等于arr[5]=8，即查找到了8这个元素，这个过程总共才查询了2次。

## 有序链表

下图是一个有序链表，如果要查找8这个元素，只能从链表头开始查找，直到遇到8位置，时间复杂度为O(n)，似乎没什么更好的办法了。

![image-20211221114635975](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211221114635975.png)

思考有序数组和有序链表的不同之处：有序数组之所以能够实现直接定位到中间元素，是因为它可以通过下标（索引）快速访问的特性。那么，如果我们给有序链表加上索引是不是就可以实现类似的功能了呢？

答案是肯定的，这种具有索引的有序链表就是跳表。

## 跳表

**怎么给有序链表加索引？**

这里需要增加一个“层”的概念，假设原始链表的层级为0，然后在其中选择一些元素向上延伸，形成第1级索引，同样地，在第1层索引的基础上，再选择一些元素向上延伸，形成第2层索引，直到你觉得索引的层数差不多了为止（没错，跳表就是这么随意）。

假设，针对上面的有序链表，加了这么一些索引：

![image-20211222235519849](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211222235519849.png)



**从哪里开始访问这个跳表？6？3？1？9？**

好像都不行，所以还要增加一个特殊的节点——头节点，放在0号元素的前面，上面的跳表增加头节点之后的样子如下：

![image-20211222235712008](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211222235712008.png)

此时，只要从h2这个节点开始，就能很快【查找】到跳表中的任意一个元素。

比如，要查找8这个元素，从h2开始先向右看一下，发现6小于8，跳到6这个位置，再向右看一下，发现9大于8，所以不要再向右跳了，向下跳一层，跳到第1层6的位置，再向右看一下，发现又是9，不能跳过去，再向下跳一层，到第0层的6，既然到第0层了，那只能按照链表依次向后（右）遍历了，直到遇到8为止，这个过程如下图：

![image-20211223094424590](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211223094424590.png)

可以看到，整个过程跳呀跳，所以取名跳表。

这里元素比较少，可能看不出跳表太大的优势，如果元素非常多，如下图所示，每两个元素向上形成一个索引，每两个索引再向上向称一个索引，最后就类似于一棵平衡二叉树了。

![image-20211221164106533](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211221164106533.png)

可以看到，每次【查找】可以减少一半的搜索范围，所以跳表查询的时间复杂度为O(logn)。

但是，实际情况下是不可能使用这种完全平衡的跳表的，因为要保持平衡的特性，在插入或删除元素时就势必需要做再平衡的操作，这样就大大降低了效率，所以，一般地，我们使用随机来决定一个元素或索引要不要产生索引。



**索引何时产生？**

最好的时机莫过于插入元素时，因为在插入元素后的下一步立马就要使用索引了，为什么这样说呢？

因为不管是插入、删除还是查询查询，都要先查找找到哪个元素才能进行下一步操作。也就是说，不管什么操作都要查询，是查询就要走索引，要走索引就要先建索引，要建索引就在插入元素的时候。

下面将使用一步一图的方式，带你领略跳表【创建（插入）】的完整过程：

1. 初始状态，只有一个头节点h0，如下图。

![image-20211223150447508](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211223150447508.png)

2. 插入一个元素4，放在h0后面，并随机决定要不要向上形成索引，假如结果是不形成索引。

![image-20211223150725520](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211223150725520.png)

3. 插入一个元素3，从h0开始查找，h0的下一个元素4大于3，所以3放在h0和4之间，然后询问要不要形成索引，假设随机决定说要形成索引，此时3向上形成索引，同时h0也向上形成索引h1，结果如下图所示：

![image-20211223150748891](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211223150748891.png)

4. 再插入一个元素9，从h1开始查找，依次经过h1->3->3->4，都没有找到为止，最后插到4后面，并询问要不要形成索引，假设随机决定要形成索引，而且我还要形成二级索引（最多比当前层数多1），结果如下图所示：

![image-20211223150826740](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211223150826740.png)

5. 接着，插入了元素1和7，它们都无惊无喜，没有形成索引，结果如下图所示：

![image-20211223150901681](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211223150901681.png)

6. 插入元素6，根据索引，查询路径为：h2->h1->3->3->4，发现4的下一个元素7比6大，所以6放在4和7之间，然后决定要不要形成索引，假如随机决定说我要形成索引，而且我也要形成2级索引，这时候就很麻烦了，在形成6这个元素的索引时，需要修改3->9和h2->9这两条线，结果如下图：

![image-20220102232443993](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220102232443993.png)

7. 最后，插入元素8和10，都无惊无喜，没有产生任何索引，所以最终的结果是：

![image-20220102232528825](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220102232528825.png)

从上面可知，跳表是一个非常随意的数据结构，即使按照同样的顺序重复插入一遍元素，生成的跳表也可能完全不一样，就是这么任性。



**上面描述了跳表插入元素的过程，删除元素的过程是怎样的呢？**

删除时，首先也要查找到元素，但是有一点小小的区别，比如删除6这个元素时，我们不能从h2->6->6->6这个路径过来，因为从这个路径过来，删除第一层的索引6后，无法修复3->9（写代码时再深入理解），所以删除元素时只能走h2->h1->3->3->4->6这条路径，且把途中每一层最后经过的索引记住，才能在删除了6这个元素之后正确地修复各层的索引。删除6之后的样子如下图：

![image-20220102232619031](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220102232619031.png)

Java的跳表ConcurrentSkipListMap中，不管是查找、插入还是删除，都是走的跟删除相同的查找路径，其实这里可以简单地优化一下，如下图所示，查找和插入时完全可以走另一条路径。

![image-20220102232718950](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220102232718950.png)

如果有兴趣，可以查看我的ConcurrentSkipListMap源码分析这篇文章。

至此，我们通过一步一图的方式完整清晰地展示了跳表的查询、插入、删除的全过程。
