## BFS

下图是一棵二叉树，那么它是如何进行BFS的？

![](https://www.coderap.cn/assets/images/2020/07/alg1.png)

BFS遍历过程：从根节点A开始，先看它有没有下一层，发现有，那么将B、C、D节点列到后面，至此得到A->B->C->D；再看B有没有下一层，发现没有；再看C有没有下一层，发现有，那么将E、F节点列到后面，至此得到A->B->C->D->E->F；然后看D有没有下一层，发现有，那么将G节点列到后面，至此得到A->B->C->D->E->F->G；接下来依次看E、F有没有下一层，发现都没有；再看G有没有下一层，发现有，那么将H、I节点列到后面，至此得到A->B->C->D->E->F->G->H->I；最后依次看H、I有没有下一层，发现都没有，至此遍历结束，结果为A->B->C->D->E->F->G->H->I。仔细观察发现，树的BFS遍历和层序遍历的结果相同。

接下来是一张无向图，那么它又是如何进行BFS的？

![](https://www.coderap.cn/assets/images/2020/07/alg2.png)

与树基本类似，不同点在于树有一个根节点，而图没有，所以BFS时必须选择一个节点（任意）作为开始遍历的节点。比如以A作为根节点，接下来看它有没有下一层（和A直接相连的节点），发现和A直接相连的有B、C，且都没有遍历过，那么将B、C节点列到后面，至此得到A->B->C；再看B有没有下一层，发现和B直接相连的节点有A、C、D，但A、C都已经遍历过了，那么只将D列到后面，至此得到A->B->C->D；再看C有没有下一层，发现和C直接相连的节点有A、B、D、E，但A、B、D都已经遍历过了，那么只将E列到后面，至此得到A->B->C->D->E；再看D有没有下一层，发现和D直接相连的节点有B、C、E、F，但B、C、E都遍历过了，那么只将F列到后面，至此得到A->B->C->D->E->F；再看E有没有下一层，发现和E直接相连的节点有C、D，但C、D都已经遍历过了；最后看F有没有下一层，发现和F相连的只有D，但D已经遍历过了，至此遍历结束，结果为A->B->C->D->E->F。

BFS使用队列实现，先创建一个空队列，然后将A入队，接下来每次从队列取出一个节点并打印，然后将该节点的所有未遍历的邻节点入队，直到队列为空为止。具体过程是A入队，A出队，打印A，A的邻节点B、C入队；B出队，打印B，B的未遍历邻节点D入队；C出队，打印C，C的未遍历邻节点E入队；D出队，打印D,D的未遍历邻节点F入队；E出队，打印E，E没有未遍历邻节点；F出队，打印F，至此队列为空，遍历结束。

Python版BFS代码：
```python
# graph={
#     "A":["B","C","D"],
#     "B":["A"],
#     "C":["A","E","F"],
#     "D":["A","G"],
#     "E":["C"],
#     "F":["C"],
#     "G":["D","H","I"],
#     "H":["G"],
#     "I":["G"]
# }

graph={
    "A":["B","C"],
    "B":["A","C","D"],
    "C":["A","B","D","E"],
    "D":["B","C","E","F"],
    "E":["C","D"],
    "F":["D"]
}

def bfs(graph,start) :
    queue=[] # 用数组实现队列
    queue.append(start) # 起始节点入队
    seen=set() # 已经遍历节点的集合
    seen.add(start)
    while(len(queue)>0): # 队列不为空
        cur=queue.pop(0) # 出队
        print(cur) # 打印出队节点
        nodes=graph[cur] # cur的所有邻节点
        for node in nodes:
            if node not in seen: # 邻节点未遍历过
                queue.append(node) # 入队
                seen.add(node) # 添加到已遍历过集合

bfs(graph,"A") # 起始点为"A"
```

## DFS

同样是上面的树，它又该如何进行DFS呢？

DFS遍历过程：从根节点A出发，有B、C、D三条路，这里选择B，至此得到A->B；接下来发现从B无路可走，回溯到A,看从A出发还有哪条路可以走，有C、D两条路，这里选择C，至此得到A->B->C；接下来从C继续往前走，有E、F三条路，这里选择E，至此得到A->B->C->E；接下来，E无路可走，回溯到C，看从C出发还有哪条路可以走，有F这一条路，至此得到A->B->C->E->F；接下来，F无路可走，回溯到C，看从C出发还有哪条路可以走，发现都已经遍历过了;继续回溯到A,看从A出发还有哪条路可以走，有D这一条路，至此得到A->B->C->E->F->D；接下来从D继续往前走，只有G一条路，至此得到A->B->C->E->F->D->G；接下来从G继续往前走，有H、I两条路，选择H，至此得到A->B->C->E->F->D->G->H；接下来，从H无路可走，回溯到G，看从G出发还有哪条路可以走，只有I一条路，至此得到A->B->C->E->F->D->G->H->I，所有的点都走完了。然后回溯到D，到A，至此遍历结束，结果为A->B->C->E->F->D->G->H->I。仔细观察发现，树的DFS遍历和前序遍历的结果相同，其实DFS包括前、中、后三种遍历。

同样是上面的无向图，它又该如何进行DFS呢？

![](https://www.coderap.cn/assets/images/2020/07/alg3.png)

如上图，DFS遍历过程：比如从A出发，有B、C两条路，这里选择B，至此得到A->B；接下来从B继续往前走，有C、D两条路，这里选择D，至此得到A->B->D；接下来从D继续往前走，有C、E、F三条路，这里选择F，至此得到A->B->D->F；接下来，F无路可走，回溯到D，看从D出发还有哪条路可以走，有C、E两条路，这里选择E，至此得到A->B->D->F->E；然后从E继续走，发现只有C一条路，至此得到A->B->D->F->E->C，所有的点都走完了。然后回溯到E，到D,到B，最后到A，至此遍历结束，结果为
A->B->D->F->E->C。

DFS用栈实现，先创建一个空栈，然后将A入栈，接下来每次出栈一个节点并打印，然后将该节点的所有未遍历的邻节点入栈，直到栈为空为止。具体过程是A入栈，A出栈，打印A，A的邻节点C、B入栈；B出栈，打印B，B的未入栈邻节点D入栈；D出栈，打印D，D的未入栈邻节点E、F入栈；F出栈，打印F,F没有未遍历邻节点；（回溯到D，看从D出发还有哪条路可以走）E出栈，打印E，E没有未遍历邻节点；C出栈，打印C，至此栈为空，遍历结束。

Python版DFS代码：
```python
# graph={
#     "A":["B","C","D"],
#     "B":["A"],
#     "C":["A","E","F"],
#     "D":["A","G"],
#     "E":["C"],
#     "F":["C"],
#     "G":["D","H","I"],
#     "H":["G"],
#     "I":["G"]
# }

graph={
    "A":["B","C"],
    "B":["A","C","D"],
    "C":["A","B","D","E"],
    "D":["B","C","E","F"],
    "E":["C","D"],
    "F":["D"]
}

def dfs(graph,start) :
    stack=[] # 用栈实现队列
    stack.append(start) # 起始节点入栈
    seen=set() # 已经遍历节点的集合
    seen.add(start)
    while(len(stack)>0): # 栈不为空
        cur=stack.pop() # 出栈
        print(cur) # 打印出栈节点
        nodes=graph[cur] # cur的所有邻节点
        for node in nodes:
            if node not in seen: # 邻节点未遍历过
                stack.append(node) # 入栈
                seen.add(node) # 添加到已遍历过集合

dfs(graph,"A") # 起始点为"A"
```

仔细观察可以发现BFS改写成DFS的代码，只需要将BFS的pop(0)改成DFS的pop()即可，为了明确两者底层使用的数据结构不同，将queue改成stack，后面这一点甚至都可以没有。

